name: Duolingo Account Generator

on:
  workflow_dispatch:
    inputs:
      amount:
        description: 'Total number of accounts to generate'
        required: true
        default: '10'
      threads:
        description: 'Number of parallel jobs (multi-threading)'
        required: true
        default: '2'
      filename:
        description: 'Output file name for the generated accounts'
        required: true
        default: 'accounts.json'

jobs:
  setup:
    runs-on: ubuntu-latest
    outputs:
      job_indices: ${{ steps.generate_matrix.outputs.result }}
    steps:
      - name: Generate job matrix
        id: generate_matrix
        run: |
          COUNT=${{ github.event.inputs.threads }}
          JSON_ARRAY=$(seq 1 $COUNT | jq -R . | jq -s -c '.')
          echo "result=$JSON_ARRAY" >> $GITHUB_OUTPUT

  generate:
    needs: setup
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        job_index: ${{ fromJson(needs.setup.outputs.job_indices) }}

    env:
      TOTAL_AMOUNT: ${{ github.event.inputs.amount }}
      TOTAL_THREADS: ${{ github.event.inputs.threads }}
      JOB_INDEX: ${{ matrix.job_index }}

    steps:
    - name: Set up Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'

    - name: Install dependencies
      run: npm install axios uuid

    - name: Create runner script
      id: create_script
      run: |
        cat << 'EOF' > runner.js
        const axios = require('axios');
        const fs = require('fs').promises;

        class DuolingoBot {
            generateMobileUserAgent() {
                const duoVersion = '6.26.2'; const androidVersion = Math.floor(Math.random() * 4) + 12;
                const buildCodes = ['AE3A', 'TQ3A', 'TP1A', 'SP2A', 'UP1A', 'RQ3A', 'RD2A', 'SD2A'];
                const buildDate = Math.floor(Math.random() * (240806 - 220101) + 220101);
                const buildSuffix = String(Math.floor(Math.random() * 999) + 1).padStart(3, '0');
                const devices = ['sdk_gphone64_x86_64', 'Pixel 6', 'Pixel 7', 'Pixel 8', 'SM-A536B', 'SM-S918B'];
                const device = devices[Math.floor(Math.random() * devices.length)];
                const buildCode = buildCodes[Math.floor(Math.random() * buildCodes.length)];
                return `Duodroid/${duoVersion} Dalvik/2.1.0 (Linux; U; Android ${androidVersion}; ${device} Build/${buildCode}.${buildDate}.${buildSuffix})`;
            }
            generateWebUserAgent() {
                const platforms = ['Windows NT 10.0; Win64; x64', 'Macintosh; Intel Mac OS X 10_15_7', 'X11; Linux x86_64'];
                const chromeVersion = `${Math.floor(Math.random() * 31) + 90}.0.${Math.floor(Math.random() * 4000) + 1000}.0`;
                const webkitVersion = `${Math.floor(Math.random() * 101) + 500}.${Math.floor(Math.random() * 100)}`;
                const platform = platforms[Math.floor(Math.random() * platforms.length)];
                return `Mozilla/5.0 (${platform}) AppleWebKit/${webkitVersion} (KHTML, like Gecko) Chrome/${chromeVersion} Safari/${webkitVersion}`;
            }
            generateUsername(minLen = 4, maxLen = 16) {
                const length = Math.floor(Math.random() * (maxLen - minLen + 1)) + minLen;
                const chars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-._';
                const letters = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';
                let username = letters[Math.floor(Math.random() * letters.length)];
                for (let i = 1; i < length; i++) { username += chars[Math.floor(Math.random() * chars.length)]; }
                return username;
            }
            generatePassword(length = 12) {
                const chars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*';
                let password = ''; for (let i = 0; i < length; i++) { password += chars[Math.floor(Math.random() * chars.length)]; }
                return password;
            }
            generateRandomEmail() {
                const domains = ['gmail.com', 'outlook.com', 'yahoo.com', 'proton.me'];
                const username = this.generateUsername(8, 12); const domain = domains[Math.floor(Math.random() * domains.length)];
                return `${username}@${domain}`;
            }
            generateRandomName() {
                const firstNames = ['Alex', 'Jordan', 'Taylor', 'Casey', 'Morgan', 'Riley', 'Avery', 'Quinn'];
                const lastNames = ['Smith', 'Johnson', 'Brown', 'Davis', 'Wilson', 'Moore', 'Taylor', 'Anderson'];
                return `${firstNames[Math.floor(Math.random() * firstNames.length)]} ${lastNames[Math.floor(Math.random() * lastNames.length)]}`;
            }
            async sleep(ms) { return new Promise(resolve => setTimeout(resolve, ms)); }
            async createUnclaimedAccount() {
                const { v4: uuidv4 } = await import('uuid');
                const headers = { 'accept': 'application/json', 'user-agent': this.generateMobileUserAgent() };
                const payload = { currentCourseId: 'DUOLINGO_FR_EN', distinctId: uuidv4(), fromLanguage: 'en' };
                const response = await axios.post(`https://android-api-cf.duolingo.com/2023-05-23/users`, payload, { headers, params: { fields: 'id,creationDate' } });
                return { userId: response.data.id, jwt: response.headers.jwt, creationDate: response.data.creationDate };
            }
            async claimAccount(userId, jwt, email, username, password, name) {
                const headers = { 'accept': 'application/json', 'authorization': `Bearer ${jwt}`, 'user-agent': this.generateMobileUserAgent() };
                const nameParts = name.split(' ');
                const payload = { requests: [{ body: JSON.stringify({ age: String(Math.floor(Math.random() * 33) + 18), email, name, firstName: nameParts[0], lastName: nameParts[nameParts.length - 1], username, password }), method: 'PATCH', url: `/2023-05-23/users/${userId}` }] };
                await axios.post(`https://android-api-cf.duolingo.com/2017-06-30/batch`, payload, { headers });
            }
            async completeFirstLesson(userId, jwt) {
                const headers = { 'Authorization': `Bearer ${jwt}`, 'User-Agent': this.generateWebUserAgent() };
                const sessionPayload = { fromLanguage: 'en', learningLanguage: 'fr', type: 'LESSON' };
                const sessionResponse = await axios.post(`https://www.duolingo.com/2017-06-30/sessions`, sessionPayload, { headers });
                const sessionData = sessionResponse.data; sessionData.failed = false; sessionData.xpGain = 15;
                await this.sleep(1500);
                await axios.put(`https://www.duolingo.com/2017-06-30/sessions/${sessionData.id}`, sessionData, { headers });
                return { xpGained: 15 };
            }
            async farmXpFromStories(userId, jwt, count = 5) {
                const headers = { 'authorization': `Bearer ${jwt}`, 'user-agent': this.generateMobileUserAgent() };
                let totalXp = 0;
                for (let i = 0; i < count; i++) {
                    const payload = { awardXp: true, fromLanguage: 'en', learningLanguage: 'fr' };
                    try {
                        const response = await axios.post('https://stories.duolingo.com/api2/stories/fr-en-le-passeport/complete', payload, { headers });
                        totalXp += response.data.xpEarned || 15; await this.sleep(1500);
                    } catch (error) { console.error(`Story ${i + 1} failed.`); }
                }
                return totalXp;
            }
        }
        async function createSingleAccount(bot) {
            const email = bot.generateRandomEmail(); const name = bot.generateRandomName();
            const username = bot.generateUsername(); const password = bot.generatePassword();
            try {
                const unclaimed = await bot.createUnclaimedAccount(); await bot.sleep(1000);
                await bot.claimAccount(unclaimed.userId, unclaimed.jwt, email, username, password, name); await bot.sleep(1000);
                const lessonResult = await bot.completeFirstLesson(unclaimed.userId, unclaimed.jwt);
                let xpGained = lessonResult.xpGained; await bot.sleep(1000);
                const storyXp = await bot.farmXpFromStories(unclaimed.userId, unclaimed.jwt, 5); xpGained += storyXp;
                return { userId: unclaimed.userId, username, email, password, jwt: unclaimed.jwt, name, totalXp: xpGained, createdAt: unclaimed.creationDate };
            } catch (error) { console.error(`Error creating account: ${error.message || error}`); return null; }
        }
        async function main() {
            const [amountStr, filename, jobIndex] = process.argv.slice(2);
            const amount = parseInt(amountStr, 10);
            const bot = new DuolingoBot(); let accounts = [];
            console.log(`Starting generation of ${amount} accounts...`);
            for (let i = 0; i < amount; i++) {
                console.log(`[${i + 1}/${amount}] Generating...`);
                const accountData = await createSingleAccount(bot);
                if (accountData) { accounts.push(accountData); console.log(`[${i + 1}/${amount}] Success: ${accountData.username}`); }
                else { console.log(`[${i + 1}/${amount}] Failed.`); }
            }
            console.log(`Writing ${accounts.length} created accounts to ${filename}`);
            await fs.writeFile(filename, JSON.stringify(accounts, null, 2));

            const jwts = accounts.map(acc => acc.jwt).join('\n');
            const jwt_filename = `jwts_${jobIndex}.txt`;
            await fs.writeFile(jwt_filename, jwts);
            console.log(`Writing ${accounts.length} JWTs to ${jwt_filename}`);

            console.log('Done.');
        }
        main();
        EOF

    - name: Calculate and run generation for this job
      run: |
        ACCOUNTS_PER_JOB=$((TOTAL_AMOUNT / TOTAL_THREADS))
        REMAINDER=$((TOTAL_AMOUNT % TOTAL_THREADS))
        if [ $JOB_INDEX -le $REMAINDER ]; then
          ACCOUNTS_PER_JOB=$((ACCOUNTS_PER_JOB + 1))
        fi
        if [ $ACCOUNTS_PER_JOB -gt 0 ]; then
          echo "This job will generate $ACCOUNTS_PER_JOB accounts."
          node runner.js $ACCOUNTS_PER_JOB "output_${JOB_INDEX}.json" $JOB_INDEX
        else
          echo "No accounts to generate for this job."
          echo "[]" > "output_${JOB_INDEX}.json"
          touch "jwts_${JOB_INDEX}.txt"
        fi

    - name: Upload partial results
      uses: actions/upload-artifact@v4
      with:
        name: accounts-part-${{ matrix.job_index }}
        path: |
          output_${{ matrix.job_index }}.json
          jwts_${{ matrix.job_index }}.txt

  combine:
    needs: generate
    runs-on: ubuntu-latest
    steps:
      - name: Install jq
        run: sudo apt-get update && sudo apt-get install -y jq

      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts

      - name: Combine JSON results
        run: |
          echo "Combining results into ${{ github.event.inputs.filename }}"
          jq -s 'add' artifacts/accounts-part-*/output_*.json > ${{ github.event.inputs.filename }}
          echo "Final file content:"
          cat ${{ github.event.inputs.filename }}

      - name: Combine JWT results
        run: |
          echo "Combining JWTs into jwts.txt"
          cat artifacts/accounts-part-*/jwts_*.txt > jwts.txt
          echo "Final JWTs:"
          cat jwts.txt

      - name: Upload final files
        uses: actions/upload-artifact@v4
        with:
          name: final-results
          path: |
            ${{ github.event.inputs.filename }}
            jwts.txt
